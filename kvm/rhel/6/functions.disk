# -*-Shell-script-*-
#
# requires:
#  bash
#  truncate, rm
#  MAKEDEV, mount, umount
#  cat, egrep, awk
#  parted, kpartx, udevadm
#  mkfs.ext4, tune2fs, mkswap
#

## disk

function mkdisk() {
  local disk_filename=$1 size=$2 unit=${3:-m}
  [[ -a ${disk_filename} ]] && { echo "already exists: ${disk_filename}" >&2; return 1; }
  truncate -s ${size}${unit} ${disk_filename}
}

function rmdisk() {
  local disk_filename=$1
  [[ -a ${disk_filename} ]] || { echo "file not found: ${disk_filename}" >&2; return 1; }
  rm -f ${disk_filename}
}

## filesystem

function mkdevice() {
  local chroot_dir=$1
  [[ -d "${chroot_dir}" ]] || { echo "directory not found: ${chroot_dir}" >&2; return 1; }
  mkdir ${chroot_dir}/dev
  for i in console null tty1 tty2 tty3 tty4 zero; do
    MAKEDEV -d ${chroot_dir}/dev -x $i
  done
}

function mkprocdir() {
  local chroot_dir=$1
  [[ -d "${chroot_dir}" ]] || { echo "directory not found: ${chroot_dir}" >&2; return 1; }
  mkdir ${chroot_dir}/proc
}

function mount_proc() {
  local chroot_dir=$1
  [[ -d "${chroot_dir}" ]] || { echo "directory not found: ${chroot_dir}" >&2; return 1; }
  mount --bind /proc ${chroot_dir}/proc
}

function mount_dev() {
  local chroot_dir=$1
  [[ -d "${chroot_dir}" ]] || { echo "directory not found: ${chroot_dir}" >&2; return 1; }
  mount --bind /dev ${chroot_dir}/dev
}

function umount_root() {
  local chroot_dir=$1
  [[ -d "${chroot_dir}" ]] || { echo "directory not found: ${chroot_dir}" >&2; return 1; }
  printf "[DEBUG] Unmounting %s\n" ${chroot_dir}
  umount ${chroot_dir}
}

function umount_nonroot() {
  local chroot_dir=$1
  [[ -d "${chroot_dir}" ]] || { echo "directory not found: ${chroot_dir}" >&2; return 1; }
  while read mountpoint; do
    printf "[DEBUG] Unmounting %s\n" ${mountpoint}
    umount ${mountpoint}
  done < <(egrep ${chroot_dir}/ /etc/mtab | awk '{print $2}')
}

## ptab

function xptabinfo() {
  {
    [[ -n "${xpart}" ]] && [[ -f "${xpart}" ]] && {
      cat ${xpart}
    } || {
      cat <<-EOS
	#
	# totalsize:${totalsize}
	#
	/boot ${bootsize}
	root  ${rootsize}
	swap  ${swapsize}
	/opt  ${optsize}
	/home ${homesize}
	EOS
    }
  } | egrep -v '^$|^#' | awk '$2 != 0 {print $1, $2}'
}

function xptabproc() {
  local blk="$(cat)"
  while read mountpoint partsize; do
    eval "${blk}"
  done < <(xptabinfo)
}

function mkpart() {
  local disk_filename=$1 parttype=$2 offset=$3 size=$4 fstype=$5
  [[ -a ${disk_filename} ]] || { echo "file not found: ${disk_filename}" >&2; return 1; }

  case "${fstype}" in
  ext2) ;;
  swap) fstype="linux-swap(new)" ;;
  esac

  local partition_start=${offset}
  local partition_end=$((${offset} + ${size} - 1))
  local previous_partition=$(parted --script -- ${disk_filename} unit s print | egrep -v '^$' | awk '$1 ~ "^[1-9]+"' | tail -1)

  case "${previous_partition}" in
  # 1st primary
  "") ;;
  # 1st logical
  *extended) partition_start=$(echo "${previous_partition}" | awk '{print $2}' | sed 's,s$,,') ;;
  # others
  *) false ;;
  esac && {
    printf "[INFO] Partition at beginning of disk - reserving first cylinder\n"
    partition_start=$((${partition_start} + 63))s
  } || :

  # whole disk
  [[ ${size} == -1 ]] && {
    partition_end=-1
  }

  printf "[INFO] Adding type %s partition to disk image: %s\n" ${fstype} ${disk_filename}
  parted --script -- ${disk_filename} mkpart ${parttype} ${fstype} ${partition_start} ${partition_end}
  # for physical /dev/XXX
  udevadm settle
}

function mkptab() {
  local disk_filename=$1
  [[ -a ${disk_filename} ]] || { echo "file not found: ${disk_filename}" >&2; return 1; }

  printf "[INFO] Adding partition table to disk image: %s\n" ${disk_filename}
  parted --script ${disk_filename} mklabel msdos

  local i=1 offset=0 parttype=
  xptabproc <<'EOS'
    case "${mountpoint}" in
    swap) fstype=swap ;;
    *)    fstype=ext2 ;;
    esac

    case "${i}" in
    [1-3])
      parttype=primary
      ;;
    4)
      parttype=extended
      # don't need to set fstype about extended partition to mkpart function.
      # extended partition ses other whole disk. "-1" measn whole disk in parted command.
      mkpart ${disk_filename} ${parttype} ${offset} -1
      # disable lba flagg
      parted --script -- ${disk_filename} set ${i} lba off
      parttype=logical
      ;;
    *)
      parttype=logical
      ;;
    esac

    mkpart ${disk_filename} ${parttype} ${offset} ${partsize} ${fstype}
    offset=$((${offset} + ${partsize}))

    case "${mountpoint}" in
    /boot)
      # set boot flag
      parted --script -- ${disk_filename} set ${i} boot on
      ;;
    esac

    let i++
EOS
}

function mapptab() {
  local disk_filename=$1
  [[ -a ${disk_filename} ]] || { echo "file not found: ${disk_filename}" >&2; return 1; }
  kpartx -va ${disk_filename} && udevadm settle
  # add map loop0p1 (253:3): 0 1998013 linear /dev/loop0 34
}

function unmapptab() {
  local disk_filename=$1
  [[ -a ${disk_filename} ]] || { echo "file not found: ${disk_filename}" >&2; return 1; }
  kpartx -vd ${disk_filename}
  # del devmap : loop0p1
}

function unmapptab_r() {
  local disk_filename=$1
  [[ -a ${disk_filename} ]] || { echo "file not found: ${disk_filename}" >&2; return 1; }
  local tries=0 max_tries=3
  while [[ ${tries} -lt ${max_tries} ]]; do
    unmapptab ${disk_filename}  && break || :
    let tries++
    sleep 1
  done
  unmapptab ${disk_filename}
}

function lsdevmap() {
  local disk_filename=$1
  [[ -a ${disk_filename} ]] || { echo "file not found: ${disk_filename}" >&2; return 1; }
  kpartx -l ${disk_filename} \
   | egrep -v "^(gpt|dos):" \
   | awk '{print $1}'
}

function devmap2path() {
  while read devmap; do
    case "${devmap}" in
    loop*)
      echo /dev/mapper/${devmap}
      ;;
    *)
      echo /dev/${devmap}
      ;;
    esac
  done < <(cat)
}

function pmapindex() {
  local name=$1
  [[ -n ${name} ]] || return 1
  local part_index=$(xptabinfo | cat -n | egrep -w ${name} | awk '{print $1}')
  case "${part_index}" in
  [1-3])
    echo ${part_index}
    ;;
  *)
    # part_index 4's part-type is "extended".
    # if part_index is more than 4, need to adjust part_index adding 1.
    echo $((${part_index} + 1))
    ;;
  esac
}

function ppartpath() {
  local disk_filename=$1 mountpoint=$2
  [[ -a ${disk_filename} ]] || { echo "file not found: ${disk_filename}" >&2; return 1; }
  [[ -n ${mountpoint} ]] || return 1
  lsdevmap ${disk_filename} | devmap2path | egrep "$(pmapindex "${mountpoint}")\$"
}

function ppartuuid() {
  local disk_filename=$1 mountpoint=$2
  [[ -a ${disk_filename} ]] || { echo "file not found: ${disk_filename}" >&2; return 1; }
  local part_filename=$(ppartpath ${disk_filename} ${mountpoint})
  blkid -c /dev/null -sUUID -ovalue ${part_filename}
}

function mkfs() {
  local disk_filename=$1
  [[ -a ${disk_filename} ]] || { echo "file not found: ${disk_filename}" >&2; return 1; }

  printf "[INFO] Creating file systems\n"
  xptabproc <<'EOS'
    printf "[DEBUG] Creating file system: \"%s\" of size: %dMB\n" ${mountpoint} ${partsize}
    part_filename=$(ppartpath ${disk_filename} ${mountpoint})
    case "${mountpoint}" in
    swap)
      # > mkswap: /dev/mapper/loop0p7: warning: don't erase bootbits sectors
      # >  on whole disk. Use -f to force.
      mkswap -f ${part_filename}
      ;;
    *)
      mkfs.ext4 -F -E lazy_itable_init=1 -L ${mountpoint} ${part_filename}
      # > This filesystem will be automatically checked every 37 mounts or 180 days, whichever comes first.
      # > Use tune2fs -c or -i to override.
      [ ! "${max_mount_count}" -eq 37 -o ! "${interval_between_check}" -eq 180 ] && {
        printf "[INFO] Setting maximal mount count: %s\n" ${max_mount_count}
        printf "[INFO] Setting interval between check(s): %s\n" ${interval_between_check}
        tune2fs -c ${max_mount_count} -i ${interval_between_check} ${part_filename}
      }
      ;;
    esac
    udevadm settle
EOS
}

## vmdisk

function mountvm_root() {
  local disk_filename=$1 chroot_dir=$2
  [[ -a ${disk_filename} ]] || { echo "file not found: ${disk_filename}" >&2; return 1; }
  [[ -d "${chroot_dir}" ]] || { echo "directory not found: ${chroot_dir}" >&2; return 1; }
  xptabproc <<'EOS'
    part_filename=$(ppartpath ${disk_filename} ${mountpoint})
    case "${mountpoint}" in
    root)
      printf "[DEBUG] Mounting %s\n" ${chroot_dir}
      mount ${part_filename} ${chroot_dir}
      ;;
    esac
EOS
}

function mountvm_nonroot() {
  local disk_filename=$1 chroot_dir=$2
  [[ -a ${disk_filename} ]] || { echo "file not found: ${disk_filename}" >&2; return 1; }
  [[ -d "${chroot_dir}" ]] || { echo "directory not found: ${chroot_dir}" >&2; return 1; }
  xptabproc <<'EOS'
    part_filename=$(ppartpath ${disk_filename} ${mountpoint})
    case "${mountpoint}" in
    root|swap) ;;
    *)
      printf "[DEBUG] Mounting %s\n" ${chroot_dir}${mountpoint}
      [[ -d ${chroot_dir}${mountpoint} ]] || mkdir -p ${chroot_dir}${mountpoint}
      mount ${part_filename} ${chroot_dir}${mountpoint}
      ;;
    esac
EOS
}

function mountvm() {
  local disk_filename=$1 chroot_dir=$2
  [[ -a ${disk_filename} ]] || { echo "file not found: ${disk_filename}" >&2; return 1; }
  [[ -d "${chroot_dir}" ]] && { echo "already exists: ${chroot_dir}" >&2; return 1; }
  mkdir -p ${chroot_dir}
  mountvm_root    ${disk_filename} ${chroot_dir}
  mountvm_nonroot ${disk_filename} ${chroot_dir}
}

function umountvm() {
  local chroot_dir=$1
  [[ -d "${chroot_dir}" ]] || { echo "directory not found: ${chroot_dir}" >&2; return 1; }
  umount_nonroot ${chroot_dir}
  umount_root    ${chroot_dir}
  rmdir ${chroot_dir}
}
